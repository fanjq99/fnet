package main

import (
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"os"
	"text/template"
)

type Result struct {
	OutFile  string    `xml:"outfile,attr"`
	MsgType  string    `xml:"msgtype,attr"`
	Messages []Message `xml:"message"`
}

type Message struct {
	ID      uint32 `xml:"id,attr"`
	Type    string `xml:"name,attr"`
	Explain string `xml:"explain,attr"`
}

const msgTemplate = `// Generated by gen_msg
// DO NOT EDIT!
syntax = "proto3";
package protocol

import (
	"reflect"

	"github.com/fanjq99/fnet"
)

enum {{.MsgType}} 
{	
	{{.MsgType}}None = 0;
	{{with .Messages}}{{range .}}
	{{.Type}}ID = {{.ID}};    //{{.Explain}}
	{{end}}{{end}}
}

func Register{{.MsgType}}Message() {
    {{with .Messages}}{{range .}}
	fnet.RegisterMessageMeta({{.ID}}, "{{.Type}}", reflect.TypeOf((*{{.Type}})(nil)).Elem())	
    {{end}}{{end}}
}
`

var filename = flag.String("file", "", "need to parse xml file name!")

func main() {
	flag.Parse()
	content, err := ioutil.ReadFile(*filename)
	if err != nil {
		fmt.Println("readfile error", err)
		return
	}

	var result Result
	err = xml.Unmarshal(content, &result)

	if err != nil {
		fmt.Println("unmarshal error", err)
		return
	}

	genfile(result, result.OutFile, msgTemplate)
}

func genfile(result Result, fileName string, temp string) {
	t := template.New("file template")
	t, _ = t.Parse(temp)

	var bf bytes.Buffer
	t.Execute(&bf, result)

	f, err := os.Create(fileName)
	if err != nil {
		fmt.Println("create file error ", err)
		return
	}

	f.Write(bf.Bytes())
	f.Close()
}
